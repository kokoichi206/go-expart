## インタプリタ

パーツ

- 字句解析器
- 構文解析器
- 抽象構文木（AST）
- 内部オブジェクトシステム
- 評価器

REPL

- Read
- Eval
- Print
- Loop

## 字句解析

2 step 

- ソースコード → トークン列（字句解析）
  - プロダクションで使うような字句解析器では、行番号や列番号、ファイル名をトークンに付加することが多い
    - あとでやってみたい
- トークン列 → 抽象構文木


## 構文解析器（パーサー）

- 入力データを受け取り、なんらかのデータ構造を構築する
- ソースコードの内部表現として使われるのは「構文木（Syntax Tree）」or「抽象構文木（AST）」
- どんな構文解析器でも利用できるような、普遍的な AST 形式などというものは**ない**
- パーサージェネレータとかもあるよ
- 戦略
  - トップダウン構文解析
    - AST のルートノードから構築を開始するもの
  - ボトムアップ構文解析
- 今回作るもの
  - トップダウン演算子優先順位
  - Pratt 構文解析器
  - 再帰下降構文解析器
- 式
  - 値を生成する
  - 10, 5, 関数リテラル
  - 関数リテラルを式として扱う、第一級市民
- 文
  - 値を生成しない
  - let x = 5;
- off-by-one バグの温床になりやすい

## Pratt 構文解析器

- トークンタイプ**ごとに**構文解析関数（semantic code）を関連づける！
- トークンタイプごとに、最大2つの構文解析関数が関連づけられる
  - トークンが前置で出現したか中置で出現したか
- 識別子
  - 式！
    - 値を生成する
  - 識別子が束縛さえrている値として評価される
- 整数リテラル
  - 式

## if 文

- ここでは if 文はその全体を式とする
  - その値は、最後に評価された方

## 関数リテラル

- 関数リテラルを式として用意する方針
- パラメータのリストと、関数本体のブロック文

## 関数の呼び出し

- 識別子と引数リストの間の `(` を中置として扱う！


## memo

- "go/token" がある
- Lisp
  - ソースコードを表現するデータ構造が、Lisp ユーザの触るものと同一
  - コードはデータで、データはコード
- さあ、これからが｢何やらよく整理されていそうだな」から「おお、これは美しい」に進むポインだ
- parseGroupedExpression あたりが、「トークンタイプに関連づけるという考え方」が輝くポイント！

## TODO

- エラー発生箇所の追加
  - ファイル名・行数
- Unicode の完全なサポート

## 疑問

- 字句解析のステップを飛ばして、いきなり AST 作るのって無理なんだっけ？
