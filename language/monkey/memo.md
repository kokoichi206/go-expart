## インタプリタ

パーツ

- 字句解析器
- 構文解析器
- 抽象構文木（AST）
- 内部オブジェクトシスえtむ
- 評価器

REPL

- Read
- Eval
- Print
- Loop

## 字句解析

2 step 

- ソースコード → トークン列（字句解析）
  - プロダクションで使うような字句解析器では、行番号や列番号、ファイル名をトークンに付加することが多い
    - あとでやってみたい
- トークン列 → 抽象構文木


## 構文解析器（パーサー）

- 入力データを受け取り、なんらかのデータ構造を構築する
- ソースコードの内部表現として使われるのは「構文木（Syntax Tree）」or「抽象構文木（AST）」
- どんな構文解析器でも利用できるような、普遍的な AST 形式などというものは**ない**
- パーサージェネレータとかもあるよ
- 戦略
  - トップダウン構文解析
    - AST のルートノードから構築を開始するもの
  - ボトムアップ構文解析
- 今回作るもの
  - トップダウン演算子優先順位
  - Pratt 構文解析器
  - 再帰下降構文解析器
- 式
  - 値を生成する
  - 10, 5, 関数リテラル
- 文
  - 値を生成しない
  - let x = 5;
- off-by-one バグの温床になりやすい


## memo

- "go/token" がある
- Lisp
  - ソースコードを表現するデータ構造が、Lisp ユーザの触るものと同一
  - コードはデータで、データはコード
- 

## TODO

- エラー発生箇所の追加
  - ファイル名・行数
- Unicode の完全なサポート

## 疑問

- 字句解析のステップを飛ばして、いきなり AST 作るのって無理なんだっけ？
