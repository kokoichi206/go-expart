## インタプリタ

パーツ

- 字句解析器
- 構文解析器
- 抽象構文木（AST）
- 内部オブジェクトシステム
- 評価器

REPL

- Read
- Eval
- Print
- Loop

## 字句解析

2 step 

- ソースコード → トークン列（字句解析）
  - プロダクションで使うような字句解析器では、行番号や列番号、ファイル名をトークンに付加することが多い
    - あとでやってみたい
- トークン列 → 抽象構文木


## 構文解析器（パーサー）

- 入力データを受け取り、なんらかのデータ構造を構築する
- ソースコードの内部表現として使われるのは「構文木（Syntax Tree）」or「抽象構文木（AST）」
- どんな構文解析器でも利用できるような、普遍的な AST 形式などというものは**ない**
- パーサージェネレータとかもあるよ
- 戦略
  - トップダウン構文解析
    - AST のルートノードから構築を開始するもの
  - ボトムアップ構文解析
- 今回作るもの
  - トップダウン演算子優先順位
  - Pratt 構文解析器
  - 再帰下降構文解析器
- 式
  - 値を生成する
  - 10, 5, 関数リテラル
  - 関数リテラルを式として扱う、第一級市民
- 文
  - 値を生成しない
  - let x = 5;
- off-by-one バグの温床になりやすい

## Pratt 構文解析器

- トークンタイプ**ごとに**構文解析関数（semantic code）を関連づける！
- トークンタイプごとに、最大2つの構文解析関数が関連づけられる
  - トークンが前置で出現したか中置で出現したか
- 識別子
  - 式！
    - 値を生成する
  - 識別子が束縛さえrている値として評価される
- 整数リテラル
  - 式

## if 文

- ここでは if 文はその全体を式とする
  - その値は、最後に評価された方

## 関数リテラル

- 関数リテラルを式として用意する方針
- パラメータのリストと、関数本体のブロック文

## 関数の呼び出し

- 識別子と引数リストの間の `(` を中置として扱う！

## 評価

- インタプリタの実装の中で、違いが最も大きく出る部分！
- 最も素直アナプローチ
  - AST を辿り、それぞれのノードを巡って、そのノードが表現していることをする
    - 全てはオンザフライ
  - tree-walking 型インタプリタ
    - すべてのアプローチの中で最も遅いだろうが
- 最近の高度に最適化された環境においては、インタプリがとコンパイラの境界線が曖昧になっている！
- また、AST を構築せず、構文解析器が素直にバイトコードを出力するケースもある
- JIT: Just In Time インタプリタ/コンパイラ
  - ソースコードを構文解析 → AST の構築 → バイトコードに変換
  - 仮想マシン上で命令を実行するのではなく、実行の直前に仮想マシンがジャストインタイムでバイトコードをネイティブの機械語に変換する
- Ruby
  - ruby 1.8 以下: tree-walking インタプリタ
  - 1.9 以上: 仮想マシンのアーキテクチャ
    - ソースコードを構文解析し、AST を構築し、それから AST をバイトコードにコンパイルし、それが仮想マシン上で実行される！

## Tree-Walking インタプリタ

- 2つさえあればいい
  - tree-walking 評価器
  - ホスト言語である Go で Monkey の値を表現
- オブジェクトシステム
  - 値システム、オブジェクト表現、的な何かが必要
  - eval 関数が何を返すかを定義する必要！
- 全てはオブジェクトであり、内部表現にラップさせている！
  - ネイティブ型のようなものは存在しない


## memo

- "go/token" がある
- Lisp
  - ソースコードを表現するデータ構造が、Lisp ユーザの触るものと同一
  - コードはデータで、データはコード
- さあ、これからが｢何やらよく整理されていそうだな」から「おお、これは美しい」に進むポインだ
- parseGroupedExpression あたりが、「トークンタイプに関連づけるという考え方」が輝くポイント！
- 有名なインタプリタのソースコード
  - https://github.com/wren-lang/wren
- let による変数束縛

## TODO

- エラー発生箇所の追加
  - ファイル名・行数
- Unicode の完全なサポート

## 疑問

- 字句解析のステップを飛ばして、いきなり AST 作るのって無理なんだっけ？
