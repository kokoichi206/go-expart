## sec 1

- Go が好まれる理由
  - 安定性
  - 表現力
  - コンパイル
  - 安全性
- 単純と容易は違う
  - 単純
    - 学んだり理解するのが複雑ではない
  - 容易
    - それほど努力しなくても何でも達成できる
- 間違いとは
  - バグ
  - 不必要な複雑さ可読性の低下
  - 最適・慣用的ではないソフトウェア構成
  - API の利便性の欠如
  - 最適化されてないコード
  - 生産性の欠如

## sec 2

- if ブロックがリターンする時は必ず else を省略する！
- init 関数
  - パッケージ初期化時
    - 1. パッケージ内の全ての定数と変数宣言の評価
    - 2. init 関数
- interface
  - インタフェースが大きいほど、抽象化は弱くなる
    - io.Reader, io.Writer はこれ以上ない強力な抽象化
  - ユースケース
    - 共通の振る舞い
    - 具体的な実装との分離
    - 振る舞いの制限
      - getter のみ準備して更新を防いだり
- インタフェース汚染
  - 抽象化は**作成するものではなく、発見するもの！**
  - **インタフェースで設計するのではなく、インタフェースを発見する**
- インタフェースを発見するべき！という立場に立つのであれば、**インタフェースはクライアント側にあるべき！**
  - **必要性に対して最も正確な抽象化を定義できる**、というメリット！
  - ほとんどの場合は、消費者側にインタフェースを定義するべき
- 自分のやることは保守的に、他人から受け入れることは寛容に
  - インタフェースの代わりに構造体を返す
  - 可能な限りインタフェースを受け付ける
- generics
  - comparable という `==` などが使える型がある！
    - map の key はこの型らしい
  - 抽象化の一種
    - 不要な抽象化は複雑さをもたらすので避けよ
- 埋め込み
  - 構造体フィールドが名前なしで宣言されている場合
  - 埋め込まれた型のフィールドやメソッドを**プロモート**するために使う
  - プロモートされたフィールドやメソッドも export されちゃうので無闇に使わない
    - sync.Mutex とかとか
  - **コンポジションであり、継承ではない！**
    - 継承とのレシーバーの違い
- プロジェクト構成
  - 優柔不断であることが唯一の誤った判断
- util パッケージは何も伝えない
  - 小さいパッケージそのものが必ずしも悪いことではない

## sec 3

- 8 進数リテラル
  - 0644 とかより **0o644 と書いた方が意味が明確になる！**
- オーバーフロー
  - 実行時の整数オーバーフローやアンダーフローは、エラーの出力なくアプリケーションもパニックにならない！
- 浮動小数点
  - **実数演算の近似**
- slice の容量の増え方
  - 1024 までは2倍で増え、それ以降は 25% ずつ増える
  - 新たな基底配列を参照するようになったとき、以前の基底配列は、すでにそれが参照されなくなった場合ヒープ上に割り当てられていれば GC で解放される
  - スライス化（半開範囲）
- nil と空スライス
  - インタフェースを設計するときは、nil スライスと空スライスを区別しないようにすべき！
- **大きなスライスや配列をスライス化すると、メモリを大量に消費する可能性がある！**
  - 残りの領域が GC に回収されていかない。。。
- ポインタ
  - **要素がポインタまたはポインタフィールドを持つ構造体の場合、その要素は GC に回収されない！**
  - 改修させるために nil で埋めるって方法がある
- map
  - マップの拡張は O(n) くらいかかる重い処理！！

## sec 4

- Go では代入されるものは全てコピー
  - **構造体を返す結果を代入すると、その構造体のコピーが行われる！**
  - **ポインタを返す関数の結果を代入すると、メモリアドレスのコピーが行われる！**
- スライス要素の更新（スライスの要素をポインタにする）
  - ポインタのスライスを反復することは、予測可能性（predictability）に欠ける
    - CPU にとって効率が悪くなるかもしれない！
      - どれくらい変わるんだろ
      - json の変換が遅い問題も解決したりするかな
- range のコピー
- range ループ内のポインタ
  - 要素を共有することになる
- map の反復処理
  - 反復はランダム**ではなく定められていない**
  - 言語設計で、意図的に選択されている！
    - マップを扱うときに順序の仮定に依存しないようにする
  - **反復中に map の追加はやばい！**
- break
  - 一番内側の for, switch, select の実行を終了させる

## sec 5

- ルーン？
  - 文字セット
    - 文字の集合のこと
    - Unicode の文字セットは `2**21` の文字を含んでいる
  - エンコーディング
    - 文字のリストを二進数で翻訳したもの
    - UTF-8 は、すべての Unicode 文字をか変なバイト数でエンコーディングするエンコーディング規格
    - 文字セットをバイナリに変換する方法
  - Unicode
    - 1つの文字で表される項目を指すための**コードポイント**
    - **ルーンは Unicode のコードポイント**
  - Unicode のコードポイントは 21 bit
    - Go ではコードポイントを保持するためのルーンは int32 のエイリアス！
- string の足し算
  - 5個以上の文字列を連結するときから strings.Builder による方法の方が性能が良くなる！
- 文字列
  - `string([]byte(log))` とかで、既定配列を変えることが可能
  - 文字列はほとんどがポインタなので、文字列を渡すための関数を読んでも、バイトの深いコピーはされない！
  - strings.Clone がある！
    - メモリリークを防ぐ
  - bytes パッケージが strings パケージと同じ操作を提供する！

## sec 6

- メソッドのレシーバ
  - ポインタである必要があるとき
    - レシーバを変更する必要がある
    - レシーバがコピーできないフィールドを含む
      - sync パッケージに一部
  - ポインタであるべき
    - 大きなオブジェクトを含む場合
  - レシーバが値でなければならない
    - 不変性を強制したい
    - レシーバがマップ、関数、チャネル
  - 値であるべき
    - 変更する必要がない
    - レシーバが基本的データ型
  - レシーバーの中のフィールドがもしポインターなどだった場合は、値レシーバーでも変更が可能！
  - **レシーバーの混在は一般的には避けるべき**
- 名前付き初期値はゼロ値で初期化される
- nil ポインタは有効なレシーバである！
  - Go の場合、メソッドは第一引数をレシーバとする関数のシンタックスシュガーにすぎない
  - **nil ポインタは有効なレシーバなので、インタフェースに変換しても nil 値は得られない！！**
  - インタフェースはディスパッチラッパー（dispatch wrapper）である？
    - ラップされている 構造体 のポインタが nil ポインタであっても、ラッパーである error インタフェースnil インタフェースではない
  - **nil ポインタから変換されたインタフェースは nil インタフェースではない！**
- defer 関数はリターンを待つことなく**引数などがすぐに評価される！**
  - `defer notify(status)` はその時点での status がはいる
    - 防ぐためには `defer notify(&status)` のようにする
  - **しかし！クロージャにしてクロージャに引数を渡すと、それは実行中に評価される！！！**

## sec 7

- sentinel error
  - グローバル変数として定義されるエラー
  - `ErrFoo` という命名
- errors.Is, errors.As
  - エラーが `%w` ヴァーブでラップされていても比較可能
- エラーを2度処理する
  - 1つのエラーに対してログが2行あるのは問題！
  - **エラーをログに記録することは、エラーを処理すること！**
    - ログを記録するか、エラーを返すかのどちらかであるべき
- もし、もしエラーを無視する場合
  - 将来の読み手のために、プランク識別子に代入する
- **エラーは常に処理されるべき！**
- **defer のエラー処理を忘れがちじゃないか？**

## sec 8

- 並行処理が並列処理を可能にする
  - 並行処理とは、一度に多くを扱うこと
  - 並列処理とは、一度に多くを行うこと
- 並行処理は構造に関するもの
  - concurrent
- 並列処理は実行に関するもの
  - parallel
- goroutine のコンテキストスイッチは、スレッドのそれより 90% ほど高速
- スケジューラ
  - GMP
    - Goroutine, Machine, Processor
- チャネルとミューテックス
  - チャネル
    - バッファなし
      - 送信ゴルーチンは、受信ゴルーチンの準備が整うまで待たされる
    - バッファあり
      - 送信ゴルーチンは、バッファがいっぱいになったとつぽのみ待たされる
  - 並列ゴルーチンか並行ゴルーチンか
    - 並行ゴルーチン: チャネル
    - 並列ゴルーチン: ミューテックス
- 競合問題（**2つを分けてきちんと理解する！**）
  - データ競合
    - **2つ以上のゴルーチンが同時に同じメモリ位置にアクセスし、少なくとも1つが書き込み中である場合に発生！**
  - 競合状態
    - **制御できないイベントの順序やタイミングに動作が依存する場合に発生！**
    - イベントのタイミング = ゴルーチンの実行順序とか
    - ゴルーチン間の特定の実行順序を保証することは、調整とオケストレーションの問題
      - チャネルとか
- 作業負荷
  - 種類
    - CPU バウンド
    - I/O バウンド
    - メモリバウンド
      - 最近は稀
  - ワーカープール
    - I/O バウンドの場合は外部システムに依存
    - CPU バウンドの場合 GOMAXPROCS に依存する形で制御可能
      - ゴルーチンレベルとスレッドレベルの両方でコンテキストスイッチの量を減らせる
- コンテキストの誤解
  - https://pkg.go.dev/context
    - Context は API の境界を超えて、デッドライン、キャンセル通知、そして他の値を伝える！
  - defer でのキャンセル？
    - 内部的には withcancel とか使うと、メモリ内に保持されるゴルーチンを作成している
    - defer で cancel を呼ぶということは、親関数を抜ける時にコンテキストがキャンセルされ、作成されたゴルーチンを停止することを意味している
    - メモリ上に保持されたオブジェクトを残さないための安全策
  - グレースフル
    - データの損失がないように後処理をきちんと行うこと
  - key, value
    - **異なるパッケージの2つの関数が同じ文字列をキーとして使うことで衝突する可能性がある！！**
    - 公開されていない独自型を作成すること。
