## sec 1

- Go が好まれる理由
  - 安定性
  - 表現力
  - コンパイル
  - 安全性
- 単純と容易は違う
  - 単純
    - 学んだり理解するのが複雑ではない
  - 容易
    - それほど努力しなくても何でも達成できる
- 間違いとは
  - バグ
  - 不必要な複雑さ可読性の低下
  - 最適・慣用的ではないソフトウェア構成
  - API の利便性の欠如
  - 最適化されてないコード
  - 生産性の欠如

## sec 2

- if ブロックがリターンする時は必ず else を省略する！
- init 関数
  - パッケージ初期化時
    - 1. パッケージ内の全ての定数と変数宣言の評価
    - 2. init 関数
- interface
  - インタフェースが大きいほど、抽象化は弱くなる
    - io.Reader, io.Writer はこれ以上ない強力な抽象化
  - ユースケース
    - 共通の振る舞い
    - 具体的な実装との分離
    - 振る舞いの制限
      - getter のみ準備して更新を防いだり
- インタフェース汚染
  - 抽象化は**作成するものではなく、発見するもの！**
  - **インタフェースで設計するのではなく、インタフェースを発見する**
- インタフェースを発見するべき！という立場に立つのであれば、**インタフェースはクライアント側にあるべき！**
  - **必要性に対して最も正確な抽象化を定義できる**、というメリット！
  - ほとんどの場合は、消費者側にインタフェースを定義するべき
- 自分のやることは保守的に、他人から受け入れることは寛容に
  - インタフェースの代わりに構造体を返す
  - 可能な限りインタフェースを受け付ける
- generics
  - comparable という `==` などが使える型がある！
    - map の key はこの型らしい
  - 抽象化の一種
    - 不要な抽象化は複雑さをもたらすので避けよ
- 埋め込み
  - 構造体フィールドが名前なしで宣言されている場合
  - 埋め込まれた型のフィールドやメソッドを**プロモート**するために使う
  - プロモートされたフィールドやメソッドも export されちゃうので無闇に使わない
    - sync.Mutex とかとか
  - **コンポジションであり、継承ではない！**
    - 継承とのレシーバーの違い
- プロジェクト構成
  - 優柔不断であることが唯一の誤った判断
- util パッケージは何も伝えない
  - 小さいパッケージそのものが必ずしも悪いことではない
