## sec 1

- Go が好まれる理由
  - 安定性
  - 表現力
  - コンパイル
  - 安全性
- 単純と容易は違う
  - 単純
    - 学んだり理解するのが複雑ではない
  - 容易
    - それほど努力しなくても何でも達成できる
- 間違いとは
  - バグ
  - 不必要な複雑さ可読性の低下
  - 最適・慣用的ではないソフトウェア構成
  - API の利便性の欠如
  - 最適化されてないコード
  - 生産性の欠如

## sec 2

- if ブロックがリターンする時は必ず else を省略する！
- init 関数
  - パッケージ初期化時
    - 1. パッケージ内の全ての定数と変数宣言の評価
    - 2. init 関数
- interface
  - インタフェースが大きいほど、抽象化は弱くなる
    - io.Reader, io.Writer はこれ以上ない強力な抽象化
  - ユースケース
    - 共通の振る舞い
    - 具体的な実装との分離
    - 振る舞いの制限
      - getter のみ準備して更新を防いだり
- インタフェース汚染
  - 抽象化は**作成するものではなく、発見するもの！**
  - **インタフェースで設計するのではなく、インタフェースを発見する**
- インタフェースを発見するべき！という立場に立つのであれば、**インタフェースはクライアント側にあるべき！**
  - **必要性に対して最も正確な抽象化を定義できる**、というメリット！
  - ほとんどの場合は、消費者側にインタフェースを定義するべき
- 自分のやることは保守的に、他人から受け入れることは寛容に
  - インタフェースの代わりに構造体を返す
  - 可能な限りインタフェースを受け付ける
- generics
  - comparable という `==` などが使える型がある！
    - map の key はこの型らしい
  - 抽象化の一種
    - 不要な抽象化は複雑さをもたらすので避けよ
- 埋め込み
  - 構造体フィールドが名前なしで宣言されている場合
  - 埋め込まれた型のフィールドやメソッドを**プロモート**するために使う
  - プロモートされたフィールドやメソッドも export されちゃうので無闇に使わない
    - sync.Mutex とかとか
  - **コンポジションであり、継承ではない！**
    - 継承とのレシーバーの違い
- プロジェクト構成
  - 優柔不断であることが唯一の誤った判断
- util パッケージは何も伝えない
  - 小さいパッケージそのものが必ずしも悪いことではない

## sec 3

- 8 進数リテラル
  - 0644 とかより **0o644 と書いた方が意味が明確になる！**
- オーバーフロー
  - 実行時の整数オーバーフローやアンダーフローは、エラーの出力なくアプリケーションもパニックにならない！
- 浮動小数点
  - **実数演算の近似**
- slice の容量の増え方
  - 1024 までは2倍で増え、それ以降は 25% ずつ増える
  - 新たな基底配列を参照するようになったとき、以前の基底配列は、すでにそれが参照されなくなった場合ヒープ上に割り当てられていれば GC で解放される
  - スライス化（半開範囲）
- nil と空スライス
  - インタフェースを設計するときは、nil スライスと空スライスを区別しないようにすべき！
- **大きなスライスや配列をスライス化すると、メモリを大量に消費する可能性がある！**
  - 残りの領域が GC に回収されていかない。。。
- ポインタ
  - **要素がポインタまたはポインタフィールドを持つ構造体の場合、その要素は GC に回収されない！**
  - 改修させるために nil で埋めるって方法がある
- map
  - マップの拡張は O(n) くらいかかる重い処理！！

## sec 4

- Go では代入されるものは全てコピー
  - **構造体を返す結果を代入すると、その構造体のコピーが行われる！**
  - **ポインタを返す関数の結果を代入すると、メモリアドレスのコピーが行われる！**
- スライス要素の更新（スライスの要素をポインタにする）
  - ポインタのスライスを反復することは、予測可能性（predictability）に欠ける
    - CPU にとって効率が悪くなるかもしれない！
      - どれくらい変わるんだろ
      - json の変換が遅い問題も解決したりするかな
- range のコピー
- range ループ内のポインタ
  - 要素を共有することになる
- map の反復処理
  - 反復はランダム**ではなく定められていない**
  - 言語設計で、意図的に選択されている！
    - マップを扱うときに順序の仮定に依存しないようにする
  - **反復中に map の追加はやばい！**
- break
  - 一番内側の for, switch, select の実行を終了させる
