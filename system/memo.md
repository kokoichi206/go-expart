## sec 1

### はじめに
システムプログラミングとは？
さまざまな定義

- C言語によるプログラミング
- アセンブリ言語を意識したC言語によるプログラミング
- 言語処理系の開発
- OS自身のプログラミング
- OSの提供する機能を使ったプログラミング

OS の機能とは、おおよそ次のもの

- メモリの管理
- プロセスの管理
- プロセス間通信
- ファイルシステム
- ネットワーク
- ユーザー管理
- タイマー

``` sh
# debugger tools for vscode
go get github.com/derekparker/delve/cmd/dlv
```

m1 mac でデバッグ実行できなかった。vscode と terminal の実行 cpu が違うっぽい。

### WHY Go for system programming
C言語の性能とPythonの書きやすさ/読みやすさを両立させ、モダンな言語の特徴をうまく取り入れた言語となることを目標に開発されたもの。

Go言語は多くのOSの機能を直接扱えて、なおかつ少ない行数で動くアプリケーションが作れる！

### デバッガーを使ってシステムコールを「見る」
Goでは処理系に全環境用のソースコードも全てバンドルされている。そのため、デバッガーで処理を追いかけていくだけで、OSの機能を直接呼び出すコードまで簡単に見ることができる！

デバッガーは実行中のプログラムの全ての情報にアクセスできてしまうので、悪意のあるユーザーが下手に実行できないように、初回起動時は認証がある。


``` sh
go get github.com/derekparker/delve/cmd/dlv
```

``` go
func (f *File) write(b []byte) (n int, err error) {
	n, err = f.pfd.Write(b)
	runtime.KeepAlive(f)
	return n, err
}


// Write implements io.Writer.
func (fd *FD) Write(p []byte) (int, error) {
	if err := fd.writeLock(); err != nil {
		return 0, err
	}
	defer fd.writeUnlock()
	if err := fd.pd.prepareWrite(fd.isFile); err != nil {
		return 0, err
	}
	var nn int
	for {
		max := len(p)
		if fd.IsStream && max-nn > maxRW {
			max = nn + maxRW
		}
		n, err := ignoringEINTRIO(syscall.Write, fd.Sysfd, p[nn:max])
		if n > 0 {
			nn += n
		}
		if nn == len(p) {
			return nn, err
		}
		if err == syscall.EAGAIN && fd.pd.pollable() {
			if err = fd.pd.waitWrite(fd.isFile); err == nil {
				continue
			}
		}
		if err != nil {
			return nn, err
		}
		if n == 0 {
			return nn, io.ErrUnexpectedEOF
		}
	}
}
```


## sec 2
Go 言語がOS直上の低レイヤーを扱いやすくするために提供している抽象化レイヤーを紹介する。

- io.Writer
  - 出力の抽象化
- io.Reader
  - 入力の抽象化
- channel
  - 通知の抽象化

### io.Writer

syscall.Write() の呼び出しを確認したが、OSではこのシステムコールを、**ファイルディスクリプタ**といわれるものに対して呼ぶ。

ファイルディスクリプタは一種の識別子（数値）であり、システムコール呼び出し時に数値に対応するものにアクセスできる。

ファイルディスクリプタは、OSがカーネルのレイヤーで用意している抽象化の仕組み。

OSはプロセスが起動されるとまず３つの擬似ファイルを作成し、それぞれにファイルディスクリプタを割り当てる。0が標準入力、1が標準出力、2が標準エラー出力。以降は、そのプロセスでファイルをオープンしたりするたびに、一ずつ大きな数が割り当てられる。

POSIX系OSでは、可能な限りさまざまなものが「ファイル」として抽象化されている！

### Interface

Go では Interface に対して、`~er, ~or` のような名前にすることが多い。（Java では ~able）

func と メソッドのシグネチャの定義の間にレシーバーを置くと、構造体にメソッドを定義したことになる！

副作用のあるメソッドではレシーバーの方をポインタ型にする！

「*File は io.Writer インタフェースを満たす」といえる。という表現をする。

### 書かれた内容を記憶しておくバッファ: bytes.Buffer

Write() で書き込まれた内容を淡々と溜めておいて後でまとめて結果を受け取れる機能もある。

それが bytes.Buffer

1.10 からは strings.Builder も同様の役割をするものとして導入されている。

### インターネットアクセスの送信

io.Writer のような抽象化は他の言語でも実装がある。

### interface の実装状況・利用状況を調べる

```
godoc -http ":6060" -analysis type
```

ただし、GOPATH にパッケージがたくさん入っている場合は、解析に時間がかかり過ぎてしまう。

### 柔軟性高く、パフォーマンスの良い設計について

データの入出力や加工を行う関数について

- ファイル名を受け取る
- io.Writer

### メモ

- `io.Reader` の機能を使って読み出しを行うと、データは消費されてしまうため、最後の buffer.String() などの取得はできない。
- `io.WriteString(buffer, "sample\n")`
- `io.MultiWriter()`
- `bufio.Writer` は、ある程度まとめて書き出すやつ
  - `Flush()` メソッドにより書き出しを行う
  - 他の言語でいう、いわゆる『バッファ付き出力』になる
- gzip された JSON を出力しながら, stdout にログを出力
  - 返したレスポンスそのままをログに残したい時！
  - io.MultiWriter として取り扱う

## sec 3

### io.Reader
``` go
type Reader interface {
  func Read(p []byte) (n int, err error)
}
```

引数である p は、読み込んだ内容を一時的に入れておくバッファ。あらかじめメモリを用意しておいて、それを使う。

``` go
// 1024 バイトのバッファを make で作る
buffer := make([]byte, 1024)
// size は実際に読み込んだバイト数、err はエラー
size, err := r.Read(buffer)
```

読み込み処理の方がめんどくさい。

### io.Reader の補助関数

Python, Ruby 等では、補助的なメソッドもファイルオブジェクトが持ってたりするが、Go言語では特別なもの以外はこのような外部のヘルパー関数を使って実現する。

#### コピーの補助関数

io.Reader から io.Writer にそのままデータを渡したい時！ファイルを開いてそのまま HTTP で転送したいとか、ハッシュ値を計算したいとか、いろいろなケースで使える

``` go
writeSize, err := io.Copy(writer, reader)
writeSize, err := io.CopyN(writer, reader, size)
```

### Interface

- io.Closer
- io.Seeker
- io.ReadAt
- 複合インタフェース
  - io.ReadWriter
  - io.ReadSeeker
  - io.ReadCloser
  - io.ReadWriteSeeker
  - ...
  - 

### いろいろ

- os.Stdin
- os.File
- 

### エンディアン変換

主流のCPUはリトルエンディアンであり、小さい桁数からメモリに格納される（0x2710 -> 10,27,0,0）。

しかし、ネットワーク上で転送されるデータの多くは、大きい桁からメモリに格納されるビックエンディアンであるため、修正がが必要となる！

### png ファイルを見てみる

PNGファイルはバイナリフォーマット。先頭の 8byte がシグニチャとなっている。

### format print
Go言語は方情報をデータが持っているため、全て「%v」と書いておけば変数の型を読み取って変換してくれる。


## sec 4

低レベルアクセスを抽象化する３つ目のGoの機能がチャネル。

### チャネル

キューは FIFO 型のデータ構造。Go言語のチャネルは、このキューに並行処理用の「並列でアクセスされても正しく処理される」ことを保証する機能を組み合わせたもの！

CSP（Communicating Sequential Processes）というモデルを、チャネルという形で実現したものになる！並行で動くコードにおいて、お互いのプロセスが同じデータを直接触るのではなく、コミュニケーションを行いつつ協調する構造にする！

- チャネルとは、データを順序よく受け渡すためのデータ構造である
- チャネルは、並列処理されても正しくデータを受け渡す同期機構である
- チャネルは、読み込み・書き込みで準備ができるまでブロックする機能である

チャネルは、クローズしなくてもガベージコレクタに回収される。

チャネルは単なるデータ構造ではなく、**言語のコアに深く組み込まれた機能**である。

for 文と組み合わせるのがよく使われる。

for ループのイテレーターに chan を使うと、チャネルがオープンしている間は回り続けるが、チャネルがクローズしたら止まるものとなる。
つまり、「値が来るたびに for ループが回る、個数が未定の動的配列」のように扱っていることになる（Python, JS のジェネレータのようなこと）。

### チャネルと select 文

select は一度トリガーすると終わってしまうため、for ループに入れて使われることがほとんど！

``` go
for {
	select {
	case data := <-reader:
		// 読み込んだ data を利用
	case <-exit:
		// ループを抜ける
		break
	}
}
```

### コンテキスト

コンテキストは、深いネストの中、あるいは派生ジョブなどがあって複雑なロジックの中でも、正しく終了やキャンセル、タイムアウトが実装できるようにするための仕組み。

### システムからの通知

OSの仕事の中には、時間のかかるものや、いつ返ってくるかわからないものがいくつかある。

- サーバーのプロセスに、クライアントからつなげてくるのを待つ
- 巨大なファイルを読み込んで、読み込み完了まで待つ
- ユーザーがマウスをクリックするまで待つ
- 他のスレッドがロックを解除するまで待つ

これらの仕事を実現するために、システムの一番下のカーネルのレイヤーでは、大きく次の３つの方式が採用されている

- OSが何かを準備するとき、それを待っているプロセスがどれかを把握し、準備が終わるまではプロセスを止め、準備ができたらプロセスに処理を戻す
  - ファイルやソケットなどの**ブロッキング入力**
- OSが何かを準備するとき、終わっていなくても即座に処理を返す。返すものが一部だけ準備できていたら、その一部のデータとまだ続きがあることを返す
  - **ノンブロッキング入力**
- プロセスが実行中であればプロセスを一時停止し、あらかじめ設定していたコールバック関数を呼ぶ
  - **シグナル**


## sec 5

システムコールとは「特権モードでOSの機能を呼ぶ」こと。

### CPU の動作モード

プロセスは自分のことだけに集中し、メモリや時間の管理はプロセスの外からOSが全て行う方式が主流。

実行してよいハードウェアとしての機能が、ソフトウェアの種類に応じて制限されており、それを動作モードによって区別している。サポートしている動作モードの種類はCPUによって異なるが、OSが動作する特権モードと、一般的なアプリケーションが動作するユーザーモードの2種類はある。

OSの機能も、アプリケーションの機能も、バイナリレベルで見れば同じようなアセンブリコードですが、CPUの動作モードが異なる。

### システムコールでモードの壁を越える

システムコールを介して、特権モードでのみ許されている機能をユーザーモードのアプリケーションから利用できるようにしている。

ん？それって、ユーザーモードに最初から許可してたらダメなん？特別な使い方のみ、にしたいってこと？ぽい。

mac の場合に、ファイルオープンの syscall が呼ばれる。

メモリの割り当て・ファイルの入出力・インターネット通信、これらはすべて特権モードでしか機能しないや〜つ。

``` go
syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))

syscall(funcPC(libc_open_trampoline), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))

// ---- asm_darwin_amd64.s の中のコード
// func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno);
TEXT	·Syscall(SB),NOSPLIT,$0-56
	CALL	runtime·entersyscall(SB)
	MOVQ	a1+8(FP), DI
	MOVQ	a2+16(FP), SI
	MOVQ	a3+24(FP), DX
	MOVQ	trap+0(FP), AX	// syscall entry
	ADDQ	$0x2000000, AX
	SYSCALL
	JCC	ok
	MOVQ	$-1, r1+32(FP)
	MOVQ	$0, r2+40(FP)
	MOVQ	AX, err+48(FP)
	CALL	runtime·exitsyscall(SB)
	RET
  ...
```

`runtime·entersyscall`から`runtime·exitsyscall`の中に、`SYSCALL`という命令がある。

POSIX（Portable Operating System Interface）は、OS間で共通のシステムコールを決めることで、アプリケーションの移植性を高めるために作られたIEEE規格のこと。最終的にOSに仕事を頼むのはシステムコールだが、POSIXで定められているのはそのインタフェースが決められている！

Go で syscall 以下の関数を使う場合、Go言語のドキュメントにはほとんどない。

### システムコールの内側

[linux のソースコード](https://github.com/torvalds/linux)の中の、[fs/read_write.c](https://github.com/torvalds/linux/blob/master/fs/read_write.c#L322)で`SYSCALL_DEFINE3`として定義されている。

[arch/x86/entry/entry_64.S#L115](https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S#L115)
	call	do_syscall_64		/* returns with IRQs disabled */

### システムコールのモニタリング

main() 関数の呼び出し前の初期化シーケンスでも大量に呼ばれる。

Linux では strace, macOS では dtruss コマンド

### エラー処理

どのシステムコールも、大抵は正常の場合には0より大きい数値、エラーの場合には-1を返すようになっている。


## sec 6

TCPソケットとHTTPの実装

### プロトコルとレイヤー

インターネット通信で採用されているのはTCP/IP参照モデルであり、トランスポート層とアプリケーション層に気にする必要がある。

### RPC

RPC（Remote Procedure Calling）は、サーバーが用意しているさまざまな機能を、ローカルコンピューター上にある関数のように簡単に呼び出そう、という仕組み。Go言語では、JSON-RPCが標準ライブラリとして提供されている。

### REST

サーバーとクライアント間の通信を、シンプルなファイルサーバーのような考え方に集約するスタイル。

Resresentational State Transfer。RESTはHTTPのルールを最大限取り入れたプロトコルとなっている。

### HATEOAS

RESTful の究極形態（第４形態）として位置付けられるもの。
レスポンスに「リンク」情報を入れ、そこから賢いクライアントプログラムが自律的にデータ検索をして情報を見つける、というもの。

HATEAOS の原則に従った API の例として、GitHub がある！

https://api.github.com/repos/kokoichi206/kokoichi206/issues

### ソケット

アプリケーション層からトランスポート層のプロトコルに対し、APIとして**ソケット**という仕組みを利用。TLSはソケットとHTTPの間に入って暗号化を行う！

一般に、他のアプリケーションとの通信をプロセス間通信という。ソケットは他と異なり、アドレスとポート番号がわかっていれば、外部のコンピュータとも通信が行える点。

ソケットにはいくつかあるが、主に次の３つ

- TCP
- UDP
  - 通信開始が早い
- Unix ドメインソケット
  - ローカルしか無理、最速

### 速度改善

- HTTP/1.1 から、Keep-Alive が導入された。
- 圧縮を行う。
- チャンク形式でボディーを送信する。
- パイプライニング
  - HTTP/2 ではストリーム、という単位の名前

### HTTP2

HTTP でいうところの1つのリクエストは、HTTP/2 ではストリームという単位で扱われる。

## sec 7

UDP はコネクションレスで、誰と繋がってるかを意識しない。複数のコンピュータに同時にメッセージを送ることが可能なマルチキャストとブロードキャストのサポート！DNS, NTP, ストリーミング動画, WebRTC などが UDP を利用

TCPには再送処理とフロー処理がある。また、ハンドシェイクに 1.5 RTT 分の時間がかかる。
往復 3 RTT はでかい。。。

### NTP

- 最上位に原子時計などの正確な情報源
  - 通信遅延を、往路と復路の時間が同一として見積もる！
    - この際に、再送処理が発生しうる TCP だと適さない
    - UDP を使う
- [Let's make an NTP client in Go](https://medium.com/learning-the-go-programming-language/lets-make-an-ntp-client-in-go-287c4b9a969f)


## sec 8

### Unix ドメインソケット

TCP と UDP によるソケット通信は、外部のネットワークにつながるインタフェースに接続する！

外部インタフェースへの接続なし、代わりにカーネル内完結で高速。**ウェブサーバーと NGINX などのリバースプロキシとの間**、あるいは**ウェブサーバーとデータベースの間の接続**を高速にできる場合がある。

ファイルシステムのパスを指定し、ソケットファイルという特殊なファイルを扱う！
ファイルという実態ではなく、プロセス間の高速な通信としてファイルというインタフェースを利用するまで。

``` sh
# 先頭の s は、ソケットファイルであることを示している！
# vscode-ssh などもたくさんあるみたい。
$ ls -la unixdomainsocket-server-sample
srwxr-xr-x  1 kokoichi  staff  0 Mar 11 05:04 unixdomainsocket-server-sample

# 作成されたソケットについての情報。
$ netstat -u
```

## sec 9

### inode

ディレクトリとは、配下に含まれるファイル名とその inode のインデックスの一覧が格納されている特殊なファイルのこと！

ディレクトリというのは、配下に含まれるファイル名とその inode のインデックスの一覧表が格納されている特別なファイル。**ファイル名の情報は**ファイルそのものではなく、**ディレクトリ側にある**！

``` sh
ls -i

man ls | grep "\-i"
     -i      For each file, print the file's file serial number (inode
     information associated with the -i, s, and -l options.
```

### ほかの話題

ストレージ上にファイルシステムは複数存在し、複雑に入り組んでいる！
仮想的なファイルシステムとして例えば /proc があり、これは物理的なストレージと対応していない、？
各プロセスの詳細情報がファイルとしてみられるように、カーネルが動的に作り出したファイルシステム！

**ジャーナリングファイルシステム**という、書き込み中に瞬断が発生してもストレージの管理領域と実際の内容に不整合が起きにくくする仕組みもある

Docker では、特定のプロセスに対して、あたかもそれがファイルシステム全体であるかのように見せる仕掛けがある。chroot など。

これらのさまざまなファイルシステムは、Linux では **VFS（Virtual File System）**というAPIで、全て統一的に扱えるようになっている。
アプリケーションからは VFS だけしか見えないため、go からの扱いはシンプルである。

### ファイルモード

権限について3桁の数字で表現するが、実際には**8進数表記であることを示すために、先頭に0をつけた**4桁で書かれる。

-rwxr-xr-x 0755
-rw-r--r-- 0644

``` go
os.Mkdir("setting", 0755)
os.MkdirAll("setting/myapp/pien", 0755)

os.Rename("oldname", "'newname")
```

ディレクトリ内部のファイル一覧を取得するには、そのディレクトリに対して『読み取り権限だけではなく、実行権限も必要』になる！

### OS内部でのファイル操作高速化

CPUにとってディスクの読み書きはとても遅い処理で、なるべく最後までやらないようにすべきタスク。そこで Linux では、 **VFS の内部に設けられているバッファを利用することで、ディスクに対する操作をなるべく回避**している。

そのため、基本的にバッファで足りるときはその範囲内で処理が行われ、そのバッファとの同期は、アプリケーションが知らないところで非同期で行われている。
`os.File` の `file.Sync()` を呼ぶと、書き込みが確実に行われる。

### 環境変数などの展開

~がホームを表すのはOSではなくてシェルが提供する機能であるため、プログラム内では特別なハンドリングが必要となる！！

``` go
// ホームディレクトリの取得

```

### ディレクトリのトラバース

ディレクトリのような木構造をすべてたどることを、**トラバース**という。`filepath.Walk()`

## sec 10

### ファイルの変更監視
変更を検知して、ローカルのファイルをエディタで再読み込みしたり、ソースコード変更時に自動コンパイルを走らせるなどで活躍。次の２通りの実装。

- 監視したいファイルをOS側に通知しておいて、変更があったら教えてもらう（パッシブな方法）
- タイマーなどで定期的にフォルダを走査し、os.Stat() などを使って変更を探しにいく（アクティブな方法）

アクティブな方法はCPU負荷やIO負荷が増える。
パッシブな方法は環境ごとの差分が大きいため、大変。サードパーティを利用するか `go get gopkg.in/fsnotify.v1`

### 同期・非同期/ブロッキング・ノンブロッキング
ファイルI/OもネットワークI/Oも、CPUの内部処理に比べると劇的に遅い。そのため、これらのデータ入出力が関係するプログラミングでは、「重い処理」に引きずられてプログラム全体が遅くならないようにする仕組みが必要！

- 同期処理
  - OSにI/Oタスクを投げて、入出力の準備ができたらアプリケーションが返ってくる
- 非同期処理
  - OSにI/Oタスクを投げて、入出力の準備ができたら通知をもらう

タスクの受け取り方で区別

- ブロッキング処理
  - お願いしたI/Oタスクの結果の準備ができるまで待つ（自分は停止）
- ノンブロッキング処理
  - お願いしたI/Oタスクの結果の準備ができるまで待たない（自分は停止しない）

以下、システムコールでの分類を見てみる

### 同期・ブロッキング処理
シンプルな実装

### 同期・ノンブロッキング処理
ファイルオープン時にノンブロッキングのフラグを付与すると実現できる。APIを呼ぶと、「まだ完了していないかのフラグ」と「現在準備ができているデータ」が得られる。完了を知る必要があるときはポーリング処理を行う。

### 非同期・ブロッキング
I/O多重化（I/Oマルチプレクサー）とも呼ばれる。select, poll などが POSIX 共通のシステムコールでは該当する。

### 非同期・ノンブロッキング処理
メインプロセスのスレッドとは完全に別のスレッドでタスクを行い、完了したらその通知だけを受け取るという処理。POSIX の API で定義されている非同期I/O（aio_*）インタフェースが有名。ただ、実装が成熟してないらしい。

### Go言語の実装
- goroutine をたくさん実行し、それぞれに同期・ノンブロッキングI/Oを担当させると、非同期・ノンブロッキングとなる
- goroutine で並行化させたI/Oの入出力でチャネルを使うことで、他の goroutine とやり取りする箇所のみ同期ができる
- このチャネルにバッファがあれば、書き込みがわもノンブロッキングになる
...

Go では基本シンタックスの組み合わせで、さまざまなI/Oのスタイルを実現できるのが強み。


## sec 11
Go の場合は、ランタイムもリンクされた単一のバイナリファイルになるため、比較的バイナリサイズが大きめ。

| で繋げたものはプロセスグループと呼ばれる

### Go言語では触れない世界
fork()/exec()

スクリプト言語では、インタプリタ内部のデータの競合が起きないよう**グローバルインタプリタロック（GIL）**と呼ばれる機構がある。

### Server::Starter
現在も利用中のユーザーを考慮しつつ、安全にサーバーを再起動するには？また、複数台サーバーがあった時の考慮は？


## sec 13
2010年代までは、CPUのコア当たりの性能向上がめざましく、「性能は時代が解決してくれるのでソフトウェアのレイヤーは生産性にフォーカスしよう」ということで、LL（Lightweight Language）と呼ばれるスクリプト言語が注目を浴びた。

### 並列・並行
CPUにおける処理時間が大きい場合（ユーザー時間が支配的な場合）は並列、I/O待ちなどでCPUが暇をしているときは並行で処理するのが基本。t

### スレッドとgoroutine
スレッドとはプログラムを実行するための「もの」で、OSが管理。

プログラムからみたスレッドは、「メモリにロードされたプログラムの現在の実行状態を保つ仮想CPU」仮想CPUのそれぞれに、スタックメモリが割り当てられる

OSやCPUから見たスレッドは、「時間が凍結されたプログラムの実行状態」実行状態には、レジスタやスタックメモリが含まれる。

OSは、凍結状態のプログラムを復元しながら、処理を回していく。

スレッドがCPUのコアに対してマッピングされるのに対し、goroutineはOSのスレッド（Goから見ると１つの仮想CPU）にマッピングされる。ここが最大の違い！！！

他のgoroutineの特徴

- IDを持たない
- 初期スタックメモリのサイズが小さい（2KB, cf: OSスレッド1~2MB）
- 優先度を持たない
- タイムスライで強制的に処理が切り替わることはない
- IDを持たないため、goroutineには外部から修了のリクエストを送る仕組みがない

goroutine は、起動時間、切り替え時間など、どれをとってもOSのスレッドの1000倍のオーダーで高速！そのため、OSのスレッドでは重くて現実的でなかったコードも書けるぞ〜例えば、HTTPのリクエスト１つに対して１つの goroutine を専門で割り当てることも可能となっておる

まじか、Go言語のランタイムは、goroutineをスレッドとみなせば、OSと同じ構造！

### Race Detector
データ競合を発見する機能


[go で書かれた OS, biscuit](https://github.com/mit-pdos/biscuit)


## sec 14
- マルチプロセス
- イベント駆動
  - 並列化ではなく並行処理
  - I/O待ちが多いプログラムで使用
- マルチスレッド
- ストリーミング・プロセッシング

### メモ
Linuxではプロセスもスレッドもカーネル上は同じ構造体で表現されている。親のプロセスとメモリ空間を共有していなければプロセス、共有していたらスレッド。

Go言語のgoroutineも軽量スレッド、ただし複数のOSスレッド上にマッピングして同時に実行されるため、並列で動作する！

並行処理とは言語のシンタックスの問題で、同時に動いてほしいという願い
並列処理とはランタイムの問題で、実際に同時に動くこと


### 並列forループ
ループ変数の実体は１つしかないためgoroutineの引数として渡し、goroutineごとにコピーが作られるようにする必要がある。


## sec 16



