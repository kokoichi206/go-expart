## sec 1

### はじめに
システムプログラミングとは？
さまざまな定義

- C言語によるプログラミング
- アセンブリ言語を意識したC言語によるプログラミング
- 言語処理系の開発
- OS自身のプログラミング
- OSの提供する機能を使ったプログラミング

OS の機能とは、おおよそ次のもの

- メモリの管理
- プロセスの管理
- プロセス間通信
- ファイルシステム
- ネットワーク
- ユーザー管理
- タイマー

``` sh
# debugger tools for vscode
go get github.com/derekparker/delve/cmd/dlv
```

m1 mac でデバッグ実行できなかった。vscode と terminal の実行 cpu が違うっぽい。

### WHY Go for system programming
C言語の性能とPythonの書きやすさ/読みやすさを両立させ、モダンな言語の特徴をうまく取り入れた言語となることを目標に開発されたもの。

Go言語は多くのOSの機能を直接扱えて、なおかつ少ない行数で動くアプリケーションが作れる！

### デバッガーを使ってシステムコールを「見る」
Goでは処理系に全環境用のソースコードも全てバンドルされている。そのため、デバッガーで処理を追いかけていくだけで、OSの機能を直接呼び出すコードまで簡単に見ることができる！

デバッガーは実行中のプログラムの全ての情報にアクセスできてしまうので、悪意のあるユーザーが下手に実行できないように、初回起動時は認証がある。


``` sh
go get github.com/derekparker/delve/cmd/dlv
```

``` go
func (f *File) write(b []byte) (n int, err error) {
	n, err = f.pfd.Write(b)
	runtime.KeepAlive(f)
	return n, err
}


// Write implements io.Writer.
func (fd *FD) Write(p []byte) (int, error) {
	if err := fd.writeLock(); err != nil {
		return 0, err
	}
	defer fd.writeUnlock()
	if err := fd.pd.prepareWrite(fd.isFile); err != nil {
		return 0, err
	}
	var nn int
	for {
		max := len(p)
		if fd.IsStream && max-nn > maxRW {
			max = nn + maxRW
		}
		n, err := ignoringEINTRIO(syscall.Write, fd.Sysfd, p[nn:max])
		if n > 0 {
			nn += n
		}
		if nn == len(p) {
			return nn, err
		}
		if err == syscall.EAGAIN && fd.pd.pollable() {
			if err = fd.pd.waitWrite(fd.isFile); err == nil {
				continue
			}
		}
		if err != nil {
			return nn, err
		}
		if n == 0 {
			return nn, io.ErrUnexpectedEOF
		}
	}
}
```


## sec 2
Go 言語がOS直上の低レイヤーを扱いやすくするために提供している抽象化レイヤーを紹介する。

- io.Writer
  - 出力の抽象化
- io.Reader
  - 入力の抽象化
- channel
  - 通知の抽象化

### io.Writer

syscall.Write() の呼び出しを確認したが、OSではこのシステムコールを、**ファイルディスクリプタ**といわれるものに対して呼ぶ。

ファイルディスクリプタは一種の識別子（数値）であり、システムコール呼び出し時に数値に対応するものにアクセスできる。

ファイルディスクリプタは、OSがカーネルのレイヤーで用意している抽象化の仕組み。

OSはプロセスが起動されるとまず３つの擬似ファイルを作成し、それぞれにファイルディスクリプタを割り当てる。0が標準入力、1が標準出力、2が標準エラー出力。以降は、そのプロセスでファイルをオープンしたりするたびに、一ずつ大きな数が割り当てられる。

POSIX系OSでは、可能な限りさまざまなものが「ファイル」として抽象化されている！

### Interface

Go では Interface に対して、`~er, ~or` のような名前にすることが多い。（Java では ~able）

func と メソッドのシグネチャの定義の間にレシーバーを置くと、構造体にメソッドを定義したことになる！

副作用のあるメソッドではレシーバーの方をポインタ型にする！

「*File は io.Writer インタフェースを満たす」といえる。という表現をする。

### 書かれた内容を記憶しておくバッファ: bytes.Buffer

Write() で書き込まれた内容を淡々と溜めておいて後でまとめて結果を受け取れる機能もある。

それが bytes.Buffer

1.10 からは strings.Builder も同様の役割をするものとして導入されている。

### インターネットアクセスの送信

io.Writer のような抽象化は他の言語でも実装がある。

### interface の実装状況・利用状況を調べる

```
godoc -http ":6060" -analysis type
```

ただし、GOPATH にパッケージがたくさん入っている場合は、解析に時間がかかり過ぎてしまう。

### 柔軟性高く、パフォーマンスの良い設計について

データの入出力や加工を行う関数について

- ファイル名を受け取る
- io.Writer

### メモ

- `io.Reader` の機能を使って読み出しを行うと、データは消費されてしまうため、最後の buffer.String() などの取得はできない。
- `io.WriteString(buffer, "sample\n")`
- `io.MultiWriter()`
- `bufio.Writer` は、ある程度まとめて書き出すやつ
  - `Flush()` メソッドにより書き出しを行う
  - 他の言語でいう、いわゆる『バッファ付き出力』になる
- gzip された JSON を出力しながら, stdout にログを出力
  - 返したレスポンスそのままをログに残したい時！
  - io.MultiWriter として取り扱う

## sec 3

### io.Reader
``` go
type Reader interface {
  func Read(p []byte) (n int, err error)
}
```

引数である p は、読み込んだ内容を一時的に入れておくバッファ。あらかじめメモリを用意しておいて、それを使う。

``` go
// 1024 バイトのバッファを make で作る
buffer := make([]byte, 1024)
// size は実際に読み込んだバイト数、err はエラー
size, err := r.Read(buffer)
```

読み込み処理の方がめんどくさい。

### io.Reader の補助関数

Python, Ruby 等では、補助的なメソッドもファイルオブジェクトが持ってたりするが、Go言語では特別なもの以外はこのような外部のヘルパー関数を使って実現する。

#### コピーの補助関数

io.Reader から io.Writer にそのままデータを渡したい時！ファイルを開いてそのまま HTTP で転送したいとか、ハッシュ値を計算したいとか、いろいろなケースで使える

``` go
writeSize, err := io.Copy(writer, reader)
writeSize, err := io.CopyN(writer, reader, size)
```

### Interface

- io.Closer
- io.Seeker
- io.ReadAt
- 複合インタフェース
  - io.ReadWriter
  - io.ReadSeeker
  - io.ReadCloser
  - io.ReadWriteSeeker
  - ...
  - 

### いろいろ

- os.Stdin
- os.File
- 

### エンディアン変換

主流のCPUはリトルエンディアンであり、小さい桁数からメモリに格納される（0x2710 -> 10,27,0,0）。

しかし、ネットワーク上で転送されるデータの多くは、大きい桁からメモリに格納されるビックエンディアンであるため、修正がが必要となる！

### png ファイルを見てみる

PNGファイルはバイナリフォーマット。先頭の 8byte がシグニチャとなっている。

### format print
Go言語は方情報をデータが持っているため、全て「%v」と書いておけば変数の型を読み取って変換してくれる。


## sec 4

低レベルアクセスを抽象化する３つ目のGoの機能がチャネル。

### チャネル

キューは FIFO 型のデータ構造。Go言語のチャネルは、このキューに並行処理用の「並列でアクセスされても正しく処理される」ことを保証する機能を組み合わせたもの！

CSP（Communicating Sequential Processes）というモデルを、チャネルという形で実現したものになる！並行で動くコードにおいて、お互いのプロセスが同じデータを直接触るのではなく、コミュニケーションを行いつつ協調する構造にする！

- チャネルとは、データを順序よく受け渡すためのデータ構造である
- チャネルは、並列処理されても正しくデータを受け渡す同期機構である
- チャネルは、読み込み・書き込みで準備ができるまでブロックする機能である

チャネルは、クローズしなくてもガベージコレクタに回収される。

チャネルは単なるデータ構造ではなく、**言語のコアに深く組み込まれた機能**である。

for 文と組み合わせるのがよく使われる。

for ループのイテレーターに chan を使うと、チャネルがオープンしている間は回り続けるが、チャネルがクローズしたら止まるものとなる。
つまり、「値が来るたびに for ループが回る、個数が未定の動的配列」のように扱っていることになる（Python, JS のジェネレータのようなこと）。

### チャネルと select 文

select は一度トリガーすると終わってしまうため、for ループに入れて使われることがほとんど！

``` go
for {
	select {
	case data := <-reader:
		// 読み込んだ data を利用
	case <-exit:
		// ループを抜ける
		break
	}
}
```

### コンテキスト

コンテキストは、深いネストの中、あるいは派生ジョブなどがあって複雑なロジックの中でも、正しく終了やキャンセル、タイムアウトが実装できるようにするための仕組み。

### システムからの通知

OSの仕事の中には、時間のかかるものや、いつ返ってくるかわからないものがいくつかある。

- サーバーのプロセスに、クライアントからつなげてくるのを待つ
- 巨大なファイルを読み込んで、読み込み完了まで待つ
- ユーザーがマウスをクリックするまで待つ
- 他のスレッドがロックを解除するまで待つ

これらの仕事を実現するために、システムの一番下のカーネルのレイヤーでは、大きく次の３つの方式が採用されている

- OSが何かを準備するとき、それを待っているプロセスがどれかを把握し、準備が終わるまではプロセスを止め、準備ができたらプロセスに処理を戻す
  - ファイルやソケットなどの**ブロッキング入力**
- OSが何かを準備するとき、終わっていなくても即座に処理を返す。返すものが一部だけ準備できていたら、その一部のデータとまだ続きがあることを返す
  - **ノンブロッキング入力**
- プロセスが実行中であればプロセスを一時停止し、あらかじめ設定していたコールバック関数を呼ぶ
  - **シグナル**


## sec 5

システムコールとは「特権モードでOSの機能を呼ぶ」こと。

### CPU の動作モード

プロセスは自分のことだけに集中し、メモリや時間の管理はプロセスの外からOSが全て行う方式が主流。

実行してよいハードウェアとしての機能が、ソフトウェアの種類に応じて制限されており、それを動作モードによって区別している。サポートしている動作モードの種類はCPUによって異なるが、OSが動作する特権モードと、一般的なアプリケーションが動作するユーザーモードの2種類はある。

OSの機能も、アプリケーションの機能も、バイナリレベルで見れば同じようなアセンブリコードですが、CPUの動作モードが異なる。

### システムコールでモードの壁を越える

システムコールを介して、特権モードでのみ許されている機能をユーザーモードのアプリケーションから利用できるようにしている。

ん？それって、ユーザーモードに最初から許可してたらダメなん？特別な使い方のみ、にしたいってこと？ぽい。

mac の場合に、ファイルオープンの syscall が呼ばれる。

メモリの割り当て・ファイルの入出力・インターネット通信、これらはすべて特権モードでしか機能しないや〜つ。

``` go
syscall.Open(name, flag|syscall.O_CLOEXEC, syscallMode(perm))

syscall(funcPC(libc_open_trampoline), uintptr(unsafe.Pointer(_p0)), uintptr(mode), uintptr(perm))

// ---- asm_darwin_amd64.s の中のコード
// func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno);
TEXT	·Syscall(SB),NOSPLIT,$0-56
	CALL	runtime·entersyscall(SB)
	MOVQ	a1+8(FP), DI
	MOVQ	a2+16(FP), SI
	MOVQ	a3+24(FP), DX
	MOVQ	trap+0(FP), AX	// syscall entry
	ADDQ	$0x2000000, AX
	SYSCALL
	JCC	ok
	MOVQ	$-1, r1+32(FP)
	MOVQ	$0, r2+40(FP)
	MOVQ	AX, err+48(FP)
	CALL	runtime·exitsyscall(SB)
	RET
  ...
```

`runtime·entersyscall`から`runtime·exitsyscall`の中に、`SYSCALL`という命令がある。

POSIX（Portable Operating System Interface）は、OS間で共通のシステムコールを決めることで、アプリケーションの移植性を高めるために作られたIEEE規格のこと。最終的にOSに仕事を頼むのはシステムコールだが、POSIXで定められているのはそのインタフェースが決められている！

Go で syscall 以下の関数を使う場合、Go言語のドキュメントにはほとんどない。

### システムコールの内側

[linux のソースコード](https://github.com/torvalds/linux)の中の、[fs/read_write.c](https://github.com/torvalds/linux/blob/master/fs/read_write.c#L322)で`SYSCALL_DEFINE3`として定義されている。

[arch/x86/entry/entry_64.S#L115](https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S#L115)
	call	do_syscall_64		/* returns with IRQs disabled */

### システムコールのモニタリング

main() 関数の呼び出し前の初期化シーケンスでも大量に呼ばれる。

Linux では strace, macOS では dtruss コマンド

### エラー処理

どのシステムコールも、大抵は正常の場合には0より大きい数値、エラーの場合には-1を返すようになっている。


## sec 6

TCPソケットとHTTPの実装

### プロトコルとレイヤー

インターネット通信で採用されているのはTCP/IP参照モデルであり、トランスポート層とアプリケーション層に気にする必要がある。

### RPC

RPC（Remote Procedure Calling）は、サーバーが用意しているさまざまな機能を、ローカルコンピューター上にある関数のように簡単に呼び出そう、という仕組み。Go言語では、JSON-RPCが標準ライブラリとして提供されている。

### REST

サーバーとクライアント間の通信を、シンプルなファイルサーバーのような考え方に集約するスタイル。

Resresentational State Transfer。RESTはHTTPのルールを最大限取り入れたプロトコルとなっている。

### HATEOAS

RESTful の究極形態（第４形態）として位置付けられるもの。
レスポンスに「リンク」情報を入れ、そこから賢いクライアントプログラムが自律的にデータ検索をして情報を見つける、というもの。

HATEAOS の原則に従った API の例として、GitHub がある！

https://api.github.com/repos/kokoichi206/kokoichi206/issues

### ソケット

アプリケーション層からトランスポート層のプロトコルに対し、APIとして**ソケット**という仕組みを利用。TLSはソケットとHTTPの間に入って暗号化を行う！

一般に、他のアプリケーションとの通信をプロセス間通信という。ソケットは他と異なり、アドレスとポート番号がわかっていれば、外部のコンピュータとも通信が行える点。

ソケットにはいくつかあるが、主に次の３つ

- TCP
- UDP
  - 通信開始が早い
- Unix ドメインソケット
  - ローカルしか無理、最速

### 速度改善

- HTTP/1.1 から、Keep-Alive が導入された。
- 圧縮を行う。
- チャンク形式でボディーを送信する。
- パイプライニング
  - HTTP/2 ではストリーム、という単位の名前

### HTTP2

HTTP でいうところの1つのリクエストは、HTTP/2 ではストリームという単位で扱われる。

## sec 7

UDP はコネクションレスで、誰と繋がってるかを意識しない。複数のコンピュータに同時にメッセージを送ることが可能なマルチキャストとブロードキャストのサポート！DNS, NTP, ストリーミング動画, WebRTC などが UDP を利用

TCPには再送処理とフロー処理がある。また、ハンドシェイクに 1.5 RTT 分の時間がかかる。
往復 3 RTT はでかい。。。

### NTP

- 最上位に原子時計などの正確な情報源
  - 通信遅延を、往路と復路の時間が同一として見積もる！
    - この際に、再送処理が発生しうる TCP だと適さない
    - UDP を使う
- [Let's make an NTP client in Go](https://medium.com/learning-the-go-programming-language/lets-make-an-ntp-client-in-go-287c4b9a969f)


## sec 8

### Unix ドメインソケット

TCP と UDP によるソケット通信は、外部のネットワークにつながるインタフェースに接続する！

外部インタフェースへの接続なし、代わりにカーネル内完結で高速。**ウェブサーバーと NGINX などのリバースプロキシとの間**、あるいは**ウェブサーバーとデータベースの間の接続**を高速にできる場合がある。

ファイルシステムのパスを指定し、ソケットファイルという特殊なファイルを扱う！
ファイルという実態ではなく、プロセス間の高速な通信としてファイルというインタフェースを利用するまで。

``` sh
# 先頭の s は、ソケットファイルであることを示している！
# vscode-ssh などもたくさんあるみたい。
$ ls -la unixdomainsocket-server-sample
srwxr-xr-x  1 kokoichi  staff  0 Mar 11 05:04 unixdomainsocket-server-sample

# 作成されたソケットについての情報。
$ netstat -u
```

## sec 9

### inode

ディレクトリとは、配下に含まれるファイル名とその inode のインデックスの一覧が格納されている特殊なファイルのこと！

ディレクトリというのは、配下に含まれるファイル名とその inode のインデックスの一覧表が格納されている特別なファイル。**ファイル名の情報は**ファイルそのものではなく、**ディレクトリ側にある**！

``` sh
ls -i

man ls | grep "\-i"
     -i      For each file, print the file's file serial number (inode
     information associated with the -i, s, and -l options.
```

### ほかの話題

ストレージ上にファイルシステムは複数存在し、複雑に入り組んでいる！
仮想的なファイルシステムとして例えば /proc があり、これは物理的なストレージと対応していない、？
各プロセスの詳細情報がファイルとしてみられるように、カーネルが動的に作り出したファイルシステム！

**ジャーナリングファイルシステム**という、書き込み中に瞬断が発生してもストレージの管理領域と実際の内容に不整合が起きにくくする仕組みもある

Docker では、特定のプロセスに対して、あたかもそれがファイルシステム全体であるかのように見せる仕掛けがある。chroot など。

これらのさまざまなファイルシステムは、Linux では **VFS（Virtual File System）**というAPIで、全て統一的に扱えるようになっている。
アプリケーションからは VFS だけしか見えないため、go からの扱いはシンプルである。

### ファイルモード

権限について3桁の数字で表現するが、実際には**8進数表記であることを示すために、先頭に0をつけた**4桁で書かれる。

-rwxr-xr-x 0755
-rw-r--r-- 0644

``` go
os.Mkdir("setting", 0755)
os.MkdirAll("setting/myapp/pien", 0755)

os.Rename("oldname", "'newname")
```

ディレクトリ内部のファイル一覧を取得するには、そのディレクトリに対して『読み取り権限だけではなく、実行権限も必要』になる！

### OS内部でのファイル操作高速化

CPUにとってディスクの読み書きはとても遅い処理で、なるべく最後までやらないようにすべきタスク。そこで Linux では、 **VFS の内部に設けられているバッファを利用することで、ディスクに対する操作をなるべく回避**している。

そのため、基本的にバッファで足りるときはその範囲内で処理が行われ、そのバッファとの同期は、アプリケーションが知らないところで非同期で行われている。
`os.File` の `file.Sync()` を呼ぶと、書き込みが確実に行われる。

### 環境変数などの展開

~がホームを表すのはOSではなくてシェルが提供する機能であるため、プログラム内では特別なハンドリングが必要となる！！

``` go
// ホームディレクトリの取得

```

### ディレクトリのトラバース

ディレクトリのような木構造をすべてたどることを、**トラバース**という。`filepath.Walk()`

## sec 10

### ファイルの変更監視

変更を検知して、ローカルのファイルをエディタで再読み込みしたり、ソースコード変更時に自動コンパイルを走らせるなどで活躍。次の２通りの実装。

- 監視したいファイルをOS側に通知しておいて、変更があったら教えてもらう（パッシブな方法）
- タイマーなどで定期的にフォルダを走査し、os.Stat() などを使って変更を探しにいく（アクティブな方法）

アクティブな方法はCPU負荷やIO負荷が増える。
パッシブな方法は環境ごとの差分が大きいため、大変。サードパーティを利用するか `go get gopkg.in/fsnotify.v1`

### マルチプラットフォーム

- Build Constraints
  - `// +build`
  - `_windows.go`
- `runtime.GOOS` 定数を使って、実行時に処理を分岐
  - API 自体がプラットフォームによって異なる場合には、リンクエラーが発生してしまう！

### 同期・非同期/ブロッキング・ノンブロッキング

`syscall.Mmap()` を使うことで、ファイルの中身をそのままメモリ上に展開できる！
同期なので、メモリのものもファイルに書き込まれる。

ファイルI/OもネットワークI/Oも、CPUの内部処理に比べると劇的に遅い。そのため、これらのデータ入出力が関係するプログラミングでは、「重い処理」に引きずられてプログラム全体が遅くならないようにする仕組みが必要！

- 同期処理
  - OSにI/Oタスクを投げて、入出力の準備ができたらアプリケーションが返ってくる
- 非同期処理
  - OSにI/Oタスクを投げて、入出力の準備ができたら通知をもらう

タスクの受け取り方で区別

- ブロッキング処理
  - お願いしたI/Oタスクの結果の準備ができるまで待つ（自分は停止）
- ノンブロッキング処理
  - お願いしたI/Oタスクの結果の準備ができるまで待たない（自分は停止しない）
  - 非同期との違い
    - 通知は来ないので、終わったかどうかを自分でもらいに行く

以下、システムコールでの分類を見てみる

### 同期・ブロッキング処理

シンプルな実装

### 同期・ノンブロッキング処理

ファイルオープン時にノンブロッキングのフラグを付与すると実現できる。APIを呼ぶと、「まだ完了していないかのフラグ」と「現在準備ができているデータ」が得られる。完了を知る必要があるときはポーリング処理を行う。

### 非同期・ブロッキング

I/O多重化（I/Oマルチプレクサー）とも呼ばれる。select, poll などが POSIX 共通のシステムコールでは該当する。

### 非同期・ノンブロッキング処理

メインプロセスのスレッドとは完全に別のスレッドでタスクを行い、完了したらその通知だけを受け取るという処理。POSIX の API で定義されている非同期I/O（aio_*）インタフェースが有名。ただ、実装が成熟してないらしい。

POSIX 非同期 (AIO) インターフェースを使うと、アプリケーションは、非同期 に (つまり、バックグラウンドで) 実行されるI/O 操作を一つ以上発行できる ようになる。

### Go言語の実装

- goroutine をたくさん実行し、それぞれに同期・ノンブロッキングI/Oを担当させると、非同期・ノンブロッキングとなる
- goroutine で並行化させたI/Oの入出力でチャネルを使うことで、他の goroutine とやり取りする箇所のみ同期ができる
- このチャネルにバッファがあれば、書き込みがわもノンブロッキングになる
...

Go では基本シンタックスの組み合わせで、さまざまなI/Oのスタイルを実現できるのが強み。

### select 属

- select 属のシステムコールとして、select と poll が POSIX にある
  - select は、扱うディスクリプタの数が増えたときの性能に問題あり
  - poll は移植性に難あり
- 多重 I/O を実現する場合、各 OS の提供する効率の良いパッケージツールを使うのが城跡
  - Linux -> epoll

## sec 11

Go の場合は、ランタイムもリンクされた単一のバイナリファイルになるため、比較的バイナリサイズが大きめ。

プロセス同士の関係は親子関係だけではない！
プロセスはそのグループを示す ID 情報を持っていて | で繋げたものはプロセスグループと呼ばれる。

↓ では、cat と echo が同じプロセスグループになる！

``` sh
cat main.go | echo
```

セッショングループという概念もあり、同じターミナルから起動したアプリが同じセッショングループになる、とかそんなかんじ。

作業フォルダもプロセスにおける大事な実行環境の1つ！
`os.Getwd()` を使って取得できる。

### ファイルディスクリプた

ファイル・ソケットなどを抽象化した概念で、どのリソースも「ファイル」として扱える。

OS がおプロセスを起動した時点で、すでに3つのファイルがオープンされている！
標準入力、標準出力、標準エラー出力に対応するファイル。

### プロセス

プロセスもも in, out がはっきりあるって意味で、他の関数やサブルーチンのようなもの

- 入力: コマンドライン引数
- 入力: 環境変数
- 出力: 終了コード

ps コマンドは `/proc` ディレクトリをパーっすして情報を得ている。

### Go言語では触れない世界

fork()/exec()

スクリプト言語では、インタプリタ内部のデータの競合が起きないよう**グローバルインタプリタロック（GIL）**と呼ばれる機構がある。

### デーモン化

- デーモンは POSIX 系の OS で動き続けるサーバープロセスなどのバックグラウンドプロセスを作るための機能
- 普通のプログラムはシェルのプロセスの子になってしまう
  - ログアウトしたりシェルを閉じたりするだけで終了してしまう！
- デーモンの工夫
  - セッションとグループを、既存のものから独立させる
  - カレントのディレクトリはルートに移動
  - ブートプロセスの init を親に設定し、実際の親はすぐに終了
  - 標準入出力を起動時のものから切り離す
- 現在では、通常のプログラムとして作って、launchctl, systemd, daemontools などで起動することが一般的

## sec 12

### シグナル

システムコールは、ユーザー空間で動作している**プロセスからカーネル空間に働きかける**ためのインタフェース。
**その逆がシグナル**である。

生成されたシグナルは、対象となるプロセスに送信される。
プロセスはシグナルを受け取ると、現在の処理を中断して受け取ったシグナルの処理を行う！

シグナルの種類は `man signal`, `man 7 signal` とかで取得できる。

### アプリケーションレベルではハンドル不可のシグナル

この2つは C 言語でもハンドルできない。

- `SIGKILL`: プロセスを強制終了する
- `SIGSTOP`: プロセスを一時停止して、バックグラウンドジョブにする

``` sh
pkill -STOP ./sample

# フォラグラウンドジョブに戻す
fg ./sample
```

### シグナルをハンドルする

- シグナルに関する設定は、プロセス全体に及ぶグローバルな設定
  - `go run` を使って実行すると、シグナルは自作コードのプロセスではなく、go コマンドのプロセスに送信されてしまう
  - `go build` コマンドで実行ファイルを作成してから実行する！

### Server::Starter

graceful restart

現在も利用中のユーザーを考慮しつつ、安全にサーバーを再起動するには？また、複数台サーバーがあった時の考慮は？

- Server::Starter
  - サーバーの再起動が必要になった時に「新しいサーバーを起動して新しいリクエストをそちらに流しつつ、古いサーバーのリクエストが完了したら正しく終了させる」ための仕組み
  - シグナルと環境変数を使った汎用の仕組み

## sec 13

2010年代までは、CPUのコア当たりの性能向上がめざましく、「性能は時代が解決してくれるのでソフトウェアのレイヤーは生産性にフォーカスしよう」ということで、LL（Lightweight Language）と呼ばれるスクリプト言語が注目を浴びた。
CPU のコア単体の性能向上がだいぶ落ち着いた（ムーアの法則の終焉？）ことがあり、複数コアを使い切る方向に関心が移ってきた。
性能の高いソフトウェアを開発する上で、多くのコアを活用することが避けられなくなってきているが、それが簡単に行えるのが Go 言語の特徴。

### 並列・並行

**CPU における処理時間が大きい場合（ユーザー時間が支配的な場合）は並列、I/O 待ちなどでCPUが暇をしているときは並行で処理する**のが基本。

### goroutine

- goroutine の起動は OS のネイティブスレッドよりは高速だが、コストゼロとはいかない
- マップの要素へのアクセスはアトミックではない！

### スレッドとgoroutine

スレッドとはプログラムを実行するための「もの」で、OSが管理。

プログラムからみたスレッドは、「メモリにロードされたプログラムの現在の実行状態を保つ仮想CPU」仮想CPUのそれぞれに、スタックメモリが割り当てられる

**OSやCPUから見たスレッドは、「時間が凍結されたプログラムの実行状態」**。
実行状態には、レジスタやスタックメモリが含まれる。
タイムスライスに沿って実行されていく！

OSは、凍結状態のプログラムを復元しながら、処理を回していく。

スレッドがCPUのコアに対してマッピングされるのに対し、goroutineはOSのスレッド（Goから見ると１つの仮想CPU）にマッピングされる。ここが最大の違い！！！

他のgoroutineの特徴

- IDを持たない
- 初期スタックメモリのサイズが小さい（2KB, cf: OSスレッド1~2MB）
- 優先度を持たない
- タイムスライで強制的に処理が切り替わることはない
- IDを持たないため、goroutineには外部から修了のリクエストを送る仕組みがない

goroutine は、起動時間、切り替え時間など、どれをとってもOSのスレッドの1000倍のオーダーで高速！そのため、OSのスレッドでは重くて現実的でなかったコードも書けるぞ〜例えば、HTTPのリクエスト１つに対して１つの goroutine を専門で割り当てることも可能となっておる

goroutine は os に処理を渡さないで作成できる。・

まじか、Go言語のランタイムは、goroutineをスレッドとみなせば、OSと同じ構造！

- 物理 CPU コア → Machine (ここが OS のスレッド)
  - どちらも M:N モデル
- スケジューラー → Process
- プロセス → goroutine

### Race Detector

データ競合を発見する機能

`go run main.go -race` など

[go で書かれた OS, biscuit](https://github.com/mit-pdos/biscuit)

### sync

- sync.Mutex/sync.RWMutex
  - **クリティカルセクション**の保護！
  - マップや配列に対する操作はアトミックではないため、複数の goroutine からアクセスする場合には保護が必要
  - cf: マルチスレッド
    - どの個所でコンテキストスイッチが発生しても不整合が起きないようにする！
  - sync.Mutex のコピー問題は、コードの静的チェックツールである `go vet` で発見できる！
- sync.Cond
  - 先に終わらせるべき作業 → 完了したら他の goroutine に通知
    - Broadcast
  - リソースの準備ができた → 待ってる他の goroutine に通知
    - signal
    - チャネルで良い
- sync.Pool
  - オブジェクトのキャッシュを実現する構造体！
  - goroutine 間でシェアできる
  - GC で回収されるので、重要なデータには向かない
- sync.Map
  - **通常の map では大量の goroutine からのアクセス時に、map の外側からロックをしないといけない**
  - **そのロックを内包し、複数の goroutine からのアクセスを保証している map !**
  - key も value も interface{} にはなってしまう
- sync.atomic
  - 全然理解してない

### 並行と並列の本来の定義

- 並行
  - システムが複数の動作（処理の流れ）を同時に実行状態（in progress）に保てる機能を備えていること
- 並列
  - 複数の動作を同時に実行できること

## sec 14

- マルチプロセス
- イベント駆動
  - 並列化ではなく並行処理
  - I/O待ちが多いプログラムで使用
- マルチスレッド
  - 同じメモリ空間内で多くの CPU が同時実行するための仕組み
  - OS のスレッドはスタックメモリ 1~2 MB を必要とする
- ストリーミング・プロセッシング

マルチスレッドには、スクリプト言語で効果を発揮しないという欠点がある。GIL や GVL という機構があるため、並列動作はできても並行動作はしない！

### GPU などの話題

- GPU におけるスレッド処理では、OS のスレッドとは異なるプログラミングモデルが必要
- 分岐ダイバージェンス
- GPU は単純な演算器を大量に並べることで解決する物量作戦
- 現代のコンピュータでは、演算器（ALU）の速度と比較してメモリの速度がボトルネックになりがち

### メモ

Linuxではプロセスもスレッドもカーネル上は同じ構造体で表現されている。親のプロセスとメモリ空間を共有していなければプロセス、共有していたらスレッド。

Go言語のgoroutineも軽量スレッド、ただし複数のOSスレッド上にマッピングして同時に実行されるため、並列で動作する！

並行処理とは言語のシンタックスの問題で、同時に動いてほしいという願い
並列処理とはランタイムの問題で、実際に同時に動くこと

### 並列forループ

ループ変数の実体は１つしかないためgoroutineの引数として渡し、goroutineごとにコピーが作られるようにする必要がある。

## sec 15

- 実行する命令は、メモリにロードして実行される
- 関数を呼び出すにも、スタックと呼ばれるメモリ領域が必要

### 物理メモリと仮想メモリ

- 細切れに余ったメモリを使って、うまく大きいメモリのタスクを捌けるか
  - → メモリ管理ユニット（MMU）と仮想メモリによって可能！
- 仮想メモリから物理メモリアドレスのアクセスは、ページテーブルが使われる

### プロセスのメモリ確保

- プロセスは起動すると OS からメモリをもらう

### ヒープとスタック

- ヒープメモリ確保: malloc()

### memo

- 構造体やプリミティブの初期化の方法がいくつかある
  - こうしたコードでは「メモリを確保する」ことをコンパイラやランタイムに指示していることになる
- Go 言語の場合、ヒープにおくかスタックに置くかはコンパイラが自動的に判断する
- スタックの方が高速なので、デフォルトではスタックを選択しようとする
- スコープの寿命が長くなる可能性がある変数などは、ヒープに逃すことがわかる！

### GC

- 多くの言語で採用されているのは、**マーク・アンド・スイープ**
  - ストップザ・ワールドが発生してまう（GC のネガティブな側面）
- Go ではストップザ・ワールドを減らすことを最優先に、GC が常に改良されている！
- Go の GC はかなーーーーりすごいみたい
  - 今は tri-color GC
  - 10 μsから 100 μsの停止時間

### メモリ配置

- バイナリフォーマットの多くは先頭にヘッダーがあるが、zip の場合は末尾にセントラルディレクトリと呼ばれるファイル情報のテーブルがある

## sec 16



