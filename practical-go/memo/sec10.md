## HTTP server

net/http パッケージは Go の並行処理の恩恵を受けているパッケージの1つ！

## Web サーバー

役割は、一昔前よりはかな〜〜り減っている

- コンテンツの描画は js
- HTML や Js の配信は CDN
- ユーザー管理・認証は ID プラットフォーム
- 昔は RDB と深く結びついていたが、今は NoSQL などもある

## net/http

以下の 3 人の登場人物は抑える！

- Handler インタフェース
- HandlerFunc 型
- ServeMux 型

Handler インタフェースは ServeHTTP メソッドを定義している。
HandlerFunc 型は、Handler インタフェースを満たしている関数型。これと同じシグネチャの関数を実装することで簡単にハンドラーとして振る舞えるようになる。

ハンドラーを呼び出すのは ServeMux 型の役割！

ServeMux 型はリクエストのパスと、リクエストされた時に対応するハンドラーの管理の**マルチプレクサ〜！**

DefauletServerMux にハンドラーを登録するには **http.HandleFunc 関数**を呼び出す。
HandlerFunc は型であるので、整理する！

- 呼び出しは, レスポンスのヘッダー、ステータスコード、ボディの順番で行う必要がある！
- 構造体以外にもメソッドを生やせる

## バリデーション

[go-playground/validator](https://github.com/go-playground/validator) などが有名である。
こちらはタグでバリデーションを指定するタイプ。

### 必須チェックのはまりどころ！

Go の**整数値は 0, bool 値は false, string 値は空文字が初期値**！！
そのためこれらの型を必須チェックに設定すると、値が設定されているのに validator でエラーが検出されてしまう。

Go 系のバリデーション処理全般に共通する仕様。
**これを避けるためには、必須チェックを行いたいフィールドをポインター型で指定する！**

``` go
type Book struct {
    Title string `validate:"required"`
    Price *int `validate:"required"`
}
```

## ファイルアップロード

マルチパートフォーム形式はメモリ効率の悪い形式！
大きいファイルを受信するためのメモリが必要となる。
**Express や Django はメモリ消費量を抑えるためにローカルファイルに一度書き出す挙動となっているが、Go はオンメモリで処理する**

## ルーター（マルチプレクサー）



## ハンドラー内部でのパニックの処理

panic からのリカバリーはハンドラー全体に共通的に言えること、処理は終了せずに 500 エラーで返すのがサーバーの責務と言える。
また、パニックが発生しても別のリクエストを受け付けられるようにするべき。

このパニックの処理って、フレームワーク使ってても大抵いるんか？

## メモ

- type と struct を分けて考える
- type は単なるエイリアス
  - だがレシーバーとなる条件だった気がする
- ループ変数の仕様
  - ループ変数はループ全体で使い回す
- クロージャーの変数参照
  - 関数の中で定義した関数は外の変数にアクセスできる
- エスケープ解析
  - go build -gcflags '-m'
  - ループ変数をヒープに移している
  - go compiler がよしなにやってくれてるところを深ぼる
- chi に用意されてる middleware
  - https://github.com/go-chi/chi/tree/master/middleware

