## 並行

- goroutine
- channel
- select

## goroutine

- すでに利用可能なメモリがプロセス内にあれば OS からヒープメモリをもらうことなく、高速に起動できる
- メモリフットプリントもかなり小さい
- C10K 問題に対し、リクエストごとにゴルーチンを作成する
- 以下のことはできない
  - スレッドオブジェクトを通じて
    - スレッドの ID を取得
    - 優先度の設定
    - 終了したかどうかの確認
    - 終了をまったり
  - Java のバーチャルスレッド（将来実装されそう。。。）
- ローカル変数を定義したときにも、それが外部の関数に渡されたり、return で返されたりすると、
  - その変数が関数の寿命よりも長く存在するものとみなして、スタックではなくヒープにメモリを確保する！
  - スタック
    - 関数実行の履歴
    - 関数内部でのみ使われるデータを保持する
    - 高速なメモリ領域
    - コールスタックとも呼ばれる
  - ヒープ
    - 確保されたメモリは任意のタイミングで破棄される
    - 確保されたメモリ領域の寿命はサブルーチンの寿命に縛られない
    - 関数の内と外で共有されるメモリ（ポインター形式で関数の引数や返り値で外に渡るもの）

## チャネル

- 複数のゴルーチンから送受信しても安全が保証されているきゅー
  - 安全 = Exactly Once

## ゴルーチンセーフ

他の言語での**スレッドセーフと同じ意味**

``` sh
go test -race
```

## ゴルーチンループ

``` go
func Worker(tasks <-chan Task, results chan<- Result) {
    for t := range tasks {
        // DO SOMETHING

        // 結果の送信
        results <- Result {
            Value: v,
            Err: err,
        }
    }
}
```



